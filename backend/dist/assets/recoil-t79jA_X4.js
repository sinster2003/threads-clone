import{R as j}from"./react-KGsOHu6s.js";import{a as Ar}from"./react-dom-PU-xc0gH.js";var Yn={};function Nr(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Lr=Nr,I=Lr;function Cr(e){return!!e&&typeof e.then=="function"}var W=Cr;function Vr(e,t){if(e!=null)return e;throw I(t??"Got unexpected null or undefined")}var q=Vr;function M(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class gt{getValue(){throw I("BaseLoadable")}toPromise(){throw I("BaseLoadable")}valueMaybe(){throw I("BaseLoadable")}valueOrThrow(){throw I(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw I("BaseLoadable")}promiseOrThrow(){throw I(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw I("BaseLoadable")}errorOrThrow(){throw I(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw I("BaseLoadable")}}class $r extends gt{constructor(t){super(),M(this,"state","hasValue"),M(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return W(n)?Le(n):Oe(n)?n:ot(n)}catch(n){return W(n)?Le(n.next(()=>this.map(t))):bt(n)}}}class Mr extends gt{constructor(t){super(),M(this,"state","hasError"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Xn extends gt{constructor(t){super(),M(this,"state","loading"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Le(this.contents.then(n=>{const o=t(n);if(Oe(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(W(n))return n.then(()=>this.map(t).contents);throw n}))}}function ot(e){return Object.freeze(new $r(e))}function bt(e){return Object.freeze(new Mr(e))}function Le(e){return Object.freeze(new Xn(e))}function Jn(){return Object.freeze(new Xn(new Promise(()=>{})))}function Ir(e){return e.every(t=>t.state==="hasValue")?ot(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?bt(q(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Le(Promise.all(e.map(t=>t.contents)))}function Qn(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Oe(r)?r:W(r)?Le(r):ot(r)),o=Ir(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,s,l)=>({...a,[s]:r[l]}),{}))}function Oe(e){return e instanceof gt}const Ur={of:e=>W(e)?Le(e):Oe(e)?e:ot(e),error:e=>bt(e),loading:()=>Jn(),all:Qn,isLoadable:Oe};var Ve={loadableWithValue:ot,loadableWithError:bt,loadableWithPromise:Le,loadableLoading:Jn,loadableAll:Qn,isLoadable:Oe,RecoilLoadable:Ur},Dr=Ve.loadableWithValue,kr=Ve.loadableWithError,Br=Ve.loadableWithPromise,Pr=Ve.loadableLoading,Or=Ve.loadableAll,xr=Ve.isLoadable,Fr=Ve.RecoilLoadable,rt=Object.freeze({__proto__:null,loadableWithValue:Dr,loadableWithError:kr,loadableWithPromise:Br,loadableLoading:Pr,loadableAll:Or,isLoadable:xr,RecoilLoadable:Fr});const Jt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function zr(e,t){var n,o;const r=(n=Yn[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw I(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function Wr(e,t){var n;const o=(n=Yn[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function Gr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(zr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{Jt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),Wr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{Jt.RECOIL_GKS_ENABLED.add(n)})}))}Gr();var Ge=Jt;function Tt(e){return Ge.RECOIL_GKS_ENABLED.has(e)}Tt.setPass=e=>{Ge.RECOIL_GKS_ENABLED.add(e)};Tt.setFail=e=>{Ge.RECOIL_GKS_ENABLED.delete(e)};Tt.clear=()=>{Ge.RECOIL_GKS_ENABLED.clear()};var z=Tt;function Kr(e,t,{error:n}={}){return null}var Hr=Kr,cn=Hr,Gt,Kt,Ht;const qr=(Gt=j.createMutableSource)!==null&&Gt!==void 0?Gt:j.unstable_createMutableSource,eo=(Kt=j.useMutableSource)!==null&&Kt!==void 0?Kt:j.unstable_useMutableSource,to=(Ht=j.useSyncExternalStore)!==null&&Ht!==void 0?Ht:j.unstable_useSyncExternalStore;function jr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=j.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;return((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null}function Zr(){return z("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:z("recoil_sync_external_store")&&to!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:z("recoil_mutable_source")&&eo!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?z("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:z("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function Yr(){return!1}var at={createMutableSource:qr,useMutableSource:eo,useSyncExternalStore:to,currentRendererSupportsUseSyncExternalStore:jr,reactMode:Zr,isFastRefreshEnabled:Yr};class ln{constructor(t){M(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class no extends ln{}class oo extends ln{}function Xr(e){return e instanceof no||e instanceof oo}var wt={AbstractRecoilValue:ln,RecoilState:no,RecoilValueReadOnly:oo,isRecoilValue:Xr},Jr=wt.AbstractRecoilValue,Qr=wt.RecoilState,ea=wt.RecoilValueReadOnly,ta=wt.isRecoilValue,xe=Object.freeze({__proto__:null,AbstractRecoilValue:Jr,RecoilState:Qr,RecoilValueReadOnly:ea,isRecoilValue:ta});function na(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var Et=na;class ro{}const oa=new ro,Ce=new Map,un=new Map;function ra(e){return Et(e,t=>q(un.get(t)))}function aa(e){if(Ce.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function sa(e){Ge.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&aa(e.key),Ce.set(e.key,e);const t=e.set==null?new xe.RecoilValueReadOnly(e.key):new xe.RecoilState(e.key);return un.set(e.key,t),t}class ao extends Error{}function ia(e){const t=Ce.get(e);if(t==null)throw new ao(`Missing definition for RecoilValue: "${e}""`);return t}function ca(e){return Ce.get(e)}const St=new Map;function la(e){var t;if(!z("recoil_memory_managament_2020"))return;const n=Ce.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ce.delete(e),(o=so(e))===null||o===void 0||o(),St.delete(e)}}function ua(e,t){z("recoil_memory_managament_2020")&&(t===void 0?St.delete(e):St.set(e,t))}function so(e){return St.get(e)}var ie={nodes:Ce,recoilValues:un,registerNode:sa,getNode:ia,getNodeMaybe:ca,deleteNodeConfigIfPossible:la,setConfigDeletionHandler:ua,getConfigDeletionHandler:so,recoilValuesForKeys:ra,NodeMissingError:ao,DefaultValue:ro,DEFAULT_VALUE:oa};function da(e,t){t()}var fa={enqueueExecution:da};function ha(e,t){return t={exports:{}},e(t,t.exports),t.exports}var va=ha(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,s=r/2,l=r/4,u={},f=function(i){return function(){return i}},v=n.hash=function(c){var i=typeof c>"u"?"undefined":t(c);if(i==="number")return c;i!=="string"&&(c+="");for(var h=0,m=0,R=c.length;m<R;++m){var g=c.charCodeAt(m);h=(h<<5)-h+g|0}return h},_=function(i){return i-=i>>1&1431655765,i=(i&858993459)+(i>>2&858993459),i=i+(i>>4)&252645135,i+=i>>8,i+=i>>16,i&127},V=function(i,h){return h>>>i&a},C=function(i){return 1<<i},y=function(i,h){return _(i&h-1)},E=function(i,h,m,R){var g=R;if(!i){var L=R.length;g=new Array(L);for(var A=0;A<L;++A)g[A]=R[A]}return g[h]=m,g},Z=function(i,h,m){var R=m.length-1,g=0,L=0,A=m;if(i)g=L=h;else for(A=new Array(R);g<h;)A[L++]=m[g++];for(++g;g<=R;)A[L++]=m[g++];return i&&(A.length=R),A},ne=function(i,h,m,R){var g=R.length;if(i){for(var L=g;L>=h;)R[L--]=R[L];return R[h]=m,R}for(var A=0,N=0,U=new Array(g+1);A<h;)U[N++]=R[A++];for(U[h]=m;A<g;)U[++N]=R[A++];return U},w=1,B=2,J=3,F=4,G={__hamt_isEmpty:!0},Y=function(i){return i===G||i&&i.__hamt_isEmpty},re=function(i,h,m,R){return{type:w,edit:i,hash:h,key:m,value:R,_modify:Ue}},Re=function(i,h,m){return{type:B,edit:i,hash:h,children:m,_modify:De}},ee=function(i,h,m){return{type:J,edit:i,mask:h,children:m,_modify:P}},ue=function(i,h,m){return{type:F,edit:i,size:h,children:m,_modify:O}},Ie=function(i){return i===G||i.type===w||i.type===B},Q=function(i,h,m,R,g){for(var L=[],A=R,N=0,U=0;A;++U)A&1&&(L[U]=g[N++]),A>>>=1;return L[h]=m,ue(i,N+1,L)},ce=function(i,h,m,R){for(var g=new Array(h-1),L=0,A=0,N=0,U=R.length;N<U;++N)if(N!==m){var H=R[N];H&&!Y(H)&&(g[L++]=H,A|=1<<N)}return ee(i,A,g)},Ee=function c(i,h,m,R,g,L){if(m===g)return Re(i,m,[L,R]);var A=V(h,m),N=V(h,g);return ee(i,C(A)|C(N),A===N?[c(i,h+o,m,R,g,L)]:A<N?[R,L]:[L,R])},de=function(i,h,m,R,g,L,A,N){for(var U=g.length,H=0;H<U;++H){var ae=g[H];if(m(A,ae.key)){var oe=ae.value,he=L(oe);return he===oe?g:he===u?(--N.value,Z(i,H,g)):E(i,H,re(h,R,A,he),g)}}var pe=L();return pe===u?g:(++N.value,E(i,U,re(h,R,A,pe),g))},ye=function(i,h){return i===h.edit},Ue=function(i,h,m,R,g,L,A){if(h(L,this.key)){var N=R(this.value);return N===this.value?this:N===u?(--A.value,G):ye(i,this)?(this.value=N,this):re(i,g,L,N)}var U=R();return U===u?this:(++A.value,Ee(i,m,this.hash,this,g,re(i,g,L,U)))},De=function(i,h,m,R,g,L,A){if(g===this.hash){var N=ye(i,this),U=de(N,i,h,this.hash,this.children,R,L,A);return U===this.children?this:U.length>1?Re(i,this.hash,U):U[0]}var H=R();return H===u?this:(++A.value,Ee(i,m,this.hash,this,g,re(i,g,L,H)))},P=function(i,h,m,R,g,L,A){var N=this.mask,U=this.children,H=V(m,g),ae=C(H),oe=y(N,ae),he=N&ae,pe=he?U[oe]:G,ke=pe._modify(i,h,m+o,R,g,L,A);if(pe===ke)return this;var ut=ye(i,this),He=N,qe=void 0;if(he&&Y(ke)){if(He&=~ae,!He)return G;if(U.length<=2&&Ie(U[oe^1]))return U[oe^1];qe=Z(ut,oe,U)}else if(!he&&!Y(ke)){if(U.length>=s)return Q(i,H,ke,N,U);He|=ae,qe=ne(ut,oe,ke,U)}else qe=E(ut,oe,ke,U);return ut?(this.mask=He,this.children=qe,this):ee(i,He,qe)},O=function(i,h,m,R,g,L,A){var N=this.size,U=this.children,H=V(m,g),ae=U[H],oe=(ae||G)._modify(i,h,m+o,R,g,L,A);if(ae===oe)return this;var he=ye(i,this),pe=void 0;if(Y(ae)&&!Y(oe))++N,pe=E(he,H,oe,U);else if(!Y(ae)&&Y(oe)){if(--N,N<=l)return ce(i,N,H,U);pe=E(he,H,G,U)}else pe=E(he,H,oe,U);return he?(this.size=N,this.children=pe,this):ue(i,N,pe)};G._modify=function(c,i,h,m,R,g,L){var A=m();return A===u?G:(++L.value,re(c,R,g,A))};function d(c,i,h,m,R){this._editable=c,this._edit=i,this._config=h,this._root=m,this._size=R}d.prototype.setTree=function(c,i){return this._editable?(this._root=c,this._size=i,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,i)};var p=n.tryGetHash=function(c,i,h,m){for(var R=m._root,g=0,L=m._config.keyEq;;)switch(R.type){case w:return L(h,R.key)?R.value:c;case B:{if(i===R.hash)for(var A=R.children,N=0,U=A.length;N<U;++N){var H=A[N];if(L(h,H.key))return H.value}return c}case J:{var ae=V(g,i),oe=C(ae);if(R.mask&oe){R=R.children[y(R.mask,oe)],g+=o;break}return c}case F:{if(R=R.children[V(g,i)],R){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,i,h){return p(c,i,h,this)};var S=n.tryGet=function(c,i,h){return p(c,h._config.hash(i),i,h)};d.prototype.tryGet=function(c,i){return S(c,i,this)};var $=n.getHash=function(c,i,h){return p(void 0,c,i,h)};d.prototype.getHash=function(c,i){return $(c,i,this)},n.get=function(c,i){return p(void 0,i._config.hash(c),c,i)},d.prototype.get=function(c,i){return S(i,c,this)};var b=n.has=function(c,i,h){return p(u,c,i,h)!==u};d.prototype.hasHash=function(c,i){return b(c,i,this)};var k=n.has=function(c,i){return b(i._config.hash(c),c,i)};d.prototype.has=function(c){return k(c,this)};var D=function(i,h){return i===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||D,hash:c&&c.hash||v},G,0)},n.empty=n.make();var T=n.isEmpty=function(c){return c&&!!Y(c._root)};d.prototype.isEmpty=function(){return T(this)};var K=n.modifyHash=function(c,i,h,m){var R={value:m._size},g=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,c,i,h,R);return m.setTree(g,R.value)};d.prototype.modifyHash=function(c,i,h){return K(h,c,i,this)};var te=n.modify=function(c,i,h){return K(c,h._config.hash(i),i,h)};d.prototype.modify=function(c,i){return te(i,c,this)};var x=n.setHash=function(c,i,h,m){return K(f(h),c,i,m)};d.prototype.setHash=function(c,i,h){return x(c,i,h,this)};var X=n.set=function(c,i,h){return x(h._config.hash(c),c,i,h)};d.prototype.set=function(c,i){return X(c,i,this)};var ve=f(u),Ae=n.removeHash=function(c,i,h){return K(ve,c,i,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,i){return Ae(c,i,this)};var fe=n.remove=function(c,i){return Ae(i._config.hash(c),c,i)};d.prototype.remove=d.prototype.delete=function(c){return fe(c,this)};var le=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return le(this)};var wn=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return wn(this)};var _r=n.mutate=function(c,i){var h=le(i);return c(h),wn(h)};d.prototype.mutate=function(c){return _r(c,this)};var Ft=function(i){return i&&En(i[0],i[1],i[2],i[3],i[4])},En=function(i,h,m,R,g){for(;m<i;){var L=h[m++];if(L&&!Y(L))return An(L,R,[i,h,m,R,g])}return Ft(g)},An=function(i,h,m){switch(i.type){case w:return{value:h(i),rest:m};case B:case F:case J:var R=i.children;return En(R.length,R,0,h,m);default:return Ft(m)}},Sr={done:!0};function zt(c){this.v=c}zt.prototype.next=function(){if(!this.v)return Sr;var c=this.v;return this.v=Ft(c.rest),c},zt.prototype[Symbol.iterator]=function(){return this};var Wt=function(i,h){return new zt(An(i._root,h))},mr=function(i){return[i.key,i.value]},Rr=n.entries=function(c){return Wt(c,mr)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return Rr(this)};var yr=function(i){return i.key},gr=n.keys=function(c){return Wt(c,yr)};d.prototype.keys=function(){return gr(this)};var br=function(i){return i.value},Tr=n.values=d.prototype.values=function(c){return Wt(c,br)};d.prototype.values=function(){return Tr(this)};var Nn=n.fold=function(c,i,h){var m=h._root;if(m.type===w)return c(i,m.value,m.key);for(var R=[m.children],g=void 0;g=R.pop();)for(var L=0,A=g.length;L<A;){var N=g[L++];N&&N.type&&(N.type===w?i=c(i,N.value,N.key):R.push(N.children))}return i};d.prototype.fold=function(c,i){return Nn(c,i,this)};var wr=n.forEach=function(c,i){return Nn(function(h,m,R){return c(m,R,i)},null,i)};d.prototype.forEach=function(c){return wr(c,this)};var Er=n.count=function(c){return c._size};d.prototype.count=function(){return Er(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class pa{constructor(t){M(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._map)}}class dn{constructor(t){if(M(this,"_hamt",va.empty.beginMutation()),t instanceof dn){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._hamt)}}function fn(e){return z("recoil_hamt_2020")?new dn(e):new pa(e)}var _a={persistentMap:fn},Sa=_a.persistentMap,ma=Object.freeze({__proto__:null,persistentMap:Sa});function Ra(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var et=Ra;function ya(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var mt=ya;function ga(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function ba(e){return{nodeDeps:mt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:mt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function qt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,s=r.get(e);if(s&&o&&s!==o.nodeDeps.get(e))return;r.set(e,t);const l=s==null?t:et(t,s);for(const u of l)a.has(u)||a.set(u,new Set),q(a.get(u)).add(e);if(s){const u=et(s,t);for(const f of u){if(!a.has(f))return;const v=q(a.get(f));v.delete(e),v.size===0&&a.delete(f)}}}function Ta(e,t,n,o){var r,a,s,l;const u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||((a=u.previousTree)===null||a===void 0||a.version);const f=n.getGraph(o);if(qt(e,t,f),o===((s=u.previousTree)===null||s===void 0?void 0:s.version)){const _=n.getGraph(u.currentTree.version);qt(e,t,_,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var v;const _=(v=u.nextTree)===null||v===void 0?void 0:v.version;if(_!==void 0){const V=n.getGraph(_);qt(e,t,V,f)}}}var st={cloneGraph:ba,graph:ga,saveDepsToStore:Ta};let wa=0;const Ea=()=>wa++;let Aa=0;const Na=()=>Aa++;let La=0;const Ca=()=>La++;var At={getNextTreeStateVersion:Ea,getNextStoreID:Na,getNextComponentID:Ca};const{persistentMap:Ln}=ma,{graph:Va}=st,{getNextTreeStateVersion:io}=At;function co(){const e=io();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Ln(),nonvalidatedAtoms:Ln()}}function $a(){const e=co();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Va()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var lo={makeEmptyTreeState:co,makeEmptyStoreState:$a,getNextTreeStateVersion:io};class uo{}function Ma(){return new uo}var Nt={RetentionZone:uo,retentionZone:Ma};function Ia(e,t){const n=new Set(e);return n.add(t),n}function Ua(e,t){const n=new Set(e);return n.delete(t),n}function Da(e,t,n){const o=new Map(e);return o.set(t,n),o}function ka(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function Ba(e,t){const n=new Map(e);return n.delete(t),n}function Pa(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var fo={setByAddingToSet:Ia,setByDeletingFromSet:Ua,mapBySettingInMap:Da,mapByUpdatingInMap:ka,mapByDeletingFromMap:Ba,mapByDeletingMultipleFromMap:Pa};function*Oa(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var hn=Oa;function xa(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var ho=xa;const{getNode:it,getNodeMaybe:Fa,recoilValuesForKeys:Cn}=ie,{RetentionZone:Vn}=Nt,{setByAddingToSet:za}=fo,Wa=Object.freeze(new Set);class Ga extends Error{}function Ka(e,t,n){if(!z("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let s=o.get(a);s||o.set(a,s=new Set),s.add(t)}if(n instanceof Vn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!z("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function s(l){const u=a.nodesRetainedByZone.get(l);u==null||u.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof Vn)s(n);else if(Array.isArray(n))for(const l of n)s(l)}}function vn(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=it(n),s=Ka(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),s()})}function Ha(e,t,n){vn(e,e.getState().currentTree,t,n)}function qa(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function ja(e,t,n){return vn(e,t,n,"get"),it(n).get(e,t)}function vo(e,t,n){return it(n).peek(e,t)}function Za(e,t,n){var o;const r=Fa(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:za(e.dirtyAtoms,t)}}function Ya(e,t,n,o){const r=it(n);if(r.set==null)throw new Ga(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return vn(e,t,n,"set"),a(e,t,o)}function Xa(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=it(n).nodeType;return ho({type:a},{loadable:()=>vo(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var s;return Cn((s=r.nodeDeps.get(n))!==null&&s!==void 0?s:[])},subscribers:()=>{var s,l;return{nodes:Cn(hn(po(e,t,new Set([n])),u=>u!==n)),components:Et((s=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&s!==void 0?s:[],([u])=>({name:u}))}}})}function po(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var s;o.add(l);const u=(s=a.nodeToNodeSubscriptions.get(l))!==null&&s!==void 0?s:Wa;for(const f of u)o.has(f)||r.push(f)}return o}var Te={getNodeLoadable:ja,peekNodeLoadable:vo,setNodeValue:Ya,initializeNode:Ha,cleanUpNode:qa,setUnvalidatedAtomValue_DEPRECATED:Za,peekNodeInfo:Xa,getDownstreamNodes:po};let _o=null;function Ja(e){_o=e}function Qa(){var e;(e=_o)===null||e===void 0||e()}var So={setInvalidateMemoizedSnapshot:Ja,invalidateMemoizedSnapshot:Qa};const{getDownstreamNodes:es,getNodeLoadable:mo,setNodeValue:ts}=Te,{getNextComponentID:ns}=At,{getNode:os,getNodeMaybe:Ro}=ie,{DefaultValue:pn}=ie,{reactMode:rs}=at,{AbstractRecoilValue:as,RecoilState:ss,RecoilValueReadOnly:is,isRecoilValue:cs}=xe,{invalidateMemoizedSnapshot:ls}=So;function us(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||(n.version,(r=a.previousTree)===null||r===void 0||r.version);const s=mo(e,n,t);return s.state==="loading"&&s.contents.catch(()=>{}),s}function ds(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof pn?n.delete(r):n.set(r,o)}),n}function fs(e,t,{key:n},o){if(typeof o=="function"){const r=mo(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw I(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function hs(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,s=fs(e,t,r,a),l=ts(e,t,r.key,s);for(const[u,f]of l.entries())Qt(t,u,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Qt(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,s=Ro(r);s==null||(o=s.invalidate)===null||o===void 0||o.call(s,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else cn(`Unknown action ${n.type}`)}function Qt(e,t,n){n.state==="hasValue"&&n.contents instanceof pn?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function yo(e,t){e.replaceState(n=>{const o=go(n);for(const r of t)hs(e,o,r);return bo(e,o),ls(),o})}function Lt(e,t){if(tt.length){const n=tt[tt.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else yo(e,[t])}const tt=[];function vs(){const e=new Map;return tt.push(e),()=>{for(const[t,n]of e)yo(t,n);tt.pop()}}function go(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function bo(e,t){const n=es(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=Ro(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function To(e,t,n){Lt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function ps(e,t,n){if(n instanceof pn)return To(e,t,n);Lt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function _s(e,t){Lt(e,{type:"markModified",recoilValue:t})}function Ss(e,t,n){Lt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function ms(e,{key:t},n,o=null){const r=ns(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),q(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const s=rs();if(s.early&&(s.mode==="LEGACY"||s.mode==="MUTABLE_SOURCE")){const l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{const l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);u===void 0||!u.has(r)||(u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t))}}}function Rs(e,t){var n;const{currentTree:o}=e.getState(),r=os(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var Se={RecoilValueReadOnly:is,AbstractRecoilValue:as,RecoilState:ss,getRecoilValueAsLoadable:us,setRecoilValue:To,setRecoilValueLoadable:ps,markRecoilValueModified:_s,setUnvalidatedRecoilValue:Ss,subscribeToRecoilValue:ms,isRecoilValue:cs,applyAtomValueWrites:ds,batchStart:vs,writeLoadableToTreeState:Qt,invalidateDownstreams:bo,copyTreeState:go,refreshRecoilValue:Rs};function ys(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var gs=ys;const{cleanUpNode:bs}=Te,{deleteNodeConfigIfPossible:Ts,getNode:wo}=ie,{RetentionZone:Eo}=Nt,ws=12e4,Ao=new Set;function No(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const s of t)if(s instanceof Eo)for(const l of Ls(n,s))r.add(l);else r.add(s);const a=Es(e,r);for(const s of a)Ns(e,o,s)}function Es(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return l(t),a;function l(u){const f=new Set,v=As(e,o,u,a,s);for(const y of v){var _;if(wo(y).retainedBy==="recoilRoot"){s.add(y);continue}if(((_=n.retention.referenceCounts.get(y))!==null&&_!==void 0?_:0)>0){s.add(y);continue}if(Lo(y).some(Z=>n.retention.referenceCounts.get(Z))){s.add(y);continue}const E=r.nodeToNodeSubscriptions.get(y);if(E&&gs(E,Z=>s.has(Z))){s.add(y);continue}a.add(y),f.add(y)}const V=new Set;for(const y of f)for(const E of(C=r.nodeDeps.get(y))!==null&&C!==void 0?C:Ao){var C;a.has(E)||V.add(E)}V.size&&l(V)}}function As(e,t,n,o,r){const a=e.getGraph(t.version),s=[],l=new Set;for(;n.size>0;)u(q(n.values().next().value));return s;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;const v=a.nodeToNodeSubscriptions.get(f);if(v)for(const _ of v)u(_);l.add(f),n.delete(f),s.push(f)}}function Ns(e,t,n){if(!z("recoil_memory_managament_2020"))return;bs(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=Lo(n);for(const u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const u=s.nodeDeps.get(n);if(u!==void 0){s.nodeDeps.delete(n);for(const f of u){var l;(l=s.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}Ts(n)}function Ls(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:Ao}function Lo(e){const t=wo(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof Eo?[t]:t}function Cs(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):No(e,new Set([t]))}function Vs(e,t,n){var o;if(!z("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Co(e,t):r.set(t,a)}function Co(e,t){if(!z("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Cs(e,t)}function $s(e){if(!z("recoil_memory_managament_2020"))return;const t=e.getState();No(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Ms(e){return e===void 0?"recoilRoot":e}var $e={SUSPENSE_TIMEOUT_MS:ws,updateRetainCount:Vs,updateRetainCountToZero:Co,releaseScheduledRetainablesNow:$s,retainedByOptionWithDefault:Ms};const{unstable_batchedUpdates:Is}=Ar;var Us={unstable_batchedUpdates:Is};const{unstable_batchedUpdates:Ds}=Us;var ks={unstable_batchedUpdates:Ds};const{batchStart:Bs}=Se,{unstable_batchedUpdates:Ps}=ks;let _n=Ps||(e=>e());const Os=e=>{_n=e},xs=()=>_n,Fs=e=>{_n(()=>{let t=()=>{};try{t=Bs(),e()}finally{t()}})};var Ct={getBatcher:xs,setBatcher:Os,batchUpdates:Fs};function*zs(e){for(const t of e)for(const n of t)yield n}var Vo=zs;const $o=typeof Window>"u"||typeof window>"u",Ws=e=>!$o&&(e===window||e instanceof Window),Gs=typeof navigator<"u"&&navigator.product==="ReactNative";var Vt={isSSR:$o,isReactNative:Gs,isWindow:Ws};function Ks(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function Hs(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e(...r)),o}}function qs(e,t){let n,o;return[(...s)=>{const l=t(...s);return n===l||(n=l,o=e(...s)),o},()=>{n=null}]}var js={memoizeWithArgsHash:Ks,memoizeOneWithArgsHash:Hs,memoizeOneWithArgsHashAndInvalidation:qs};const{batchUpdates:en}=Ct,{initializeNode:Zs,peekNodeInfo:Ys}=Te,{graph:Xs}=st,{getNextStoreID:Js}=At,{DEFAULT_VALUE:Qs,recoilValues:$n,recoilValuesForKeys:Mn}=ie,{AbstractRecoilValue:ei,getRecoilValueAsLoadable:ti,setRecoilValue:In,setUnvalidatedRecoilValue:ni}=Se,{updateRetainCount:_t}=$e,{setInvalidateMemoizedSnapshot:oi}=So,{getNextTreeStateVersion:ri,makeEmptyStoreState:ai}=lo,{isSSR:si}=Vt,{memoizeOneWithArgsHashAndInvalidation:ii}=js;class $t{constructor(t,n){M(this,"_store",void 0),M(this,"_refCount",1),M(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),ti(this._store,o))),M(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),M(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const s=this._store.getState().currentTree;return Mn(s.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?$n.values():o.isInitialized===!0?Mn(Vo([r,a])):hn($n.values(),({key:s})=>!r.has(s)&&!a.has(s))}),M(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),Ys(this._store,this._store.getState().currentTree,o))),M(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return o(r),r}),M(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:Js(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return q(r.get(o));const a=Xs();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw I("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)Zs(this._store,o,"get"),_t(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0,this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){si||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!z("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){z("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function Mo(e,t,n=!1){const o=e.getState(),r=n?ri():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Et(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function ci(e){const t=new $t(ai());return e!=null?t.map(e):t}const[Un,Io]=ii((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:q(o.previousTree);return new $t(Mo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});oi(Io);function li(e,t="latest"){const n=Un(e,t);return n.isRetained()?n:(Io(),Un(e,t))}class tn extends $t{constructor(t,n){super(Mo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),M(this,"_batch",void 0),M(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{_t(a,o.key,1),In(this.getStore_INTERNAL(),o,r)})}),M(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{_t(r,o.key,1),In(this.getStore_INTERNAL(),o,Qs)})}),M(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();en(()=>{for(const[a,s]of o.entries())_t(r,a,1),ni(r,new ei(a),s)})}),this._batch=n}}var Mt={Snapshot:$t,MutableSnapshot:tn,freshSnapshot:ci,cloneSnapshot:li},ui=Mt.Snapshot,di=Mt.MutableSnapshot,fi=Mt.freshSnapshot,hi=Mt.cloneSnapshot,It=Object.freeze({__proto__:null,Snapshot:ui,MutableSnapshot:di,freshSnapshot:fi,cloneSnapshot:hi});function vi(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var pi=vi;const{useRef:_i}=j;function Si(e){const t=_i(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var Dn=Si;const{getNextTreeStateVersion:mi,makeEmptyStoreState:Uo}=lo,{cleanUpNode:Ri,getDownstreamNodes:yi,initializeNode:gi,setNodeValue:bi,setUnvalidatedAtomValue_DEPRECATED:Ti}=Te,{graph:wi}=st,{cloneGraph:Ei}=st,{getNextStoreID:Do}=At,{createMutableSource:jt,reactMode:ko}=at,{applyAtomValueWrites:Ai}=Se,{releaseScheduledRetainablesNow:Bo}=$e,{freshSnapshot:Ni}=It,{useCallback:Li,useContext:Po,useEffect:nn,useMemo:Ci,useRef:Vi,useState:$i}=j;function je(){throw I("This component must be used inside a <RecoilRoot> component.")}const Oo=Object.freeze({storeID:Do(),getState:je,replaceState:je,getGraph:je,subscribeToTransactions:je,addTransactionMetadata:je});let on=!1;function kn(e){if(on)throw I("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){z("recoil_memory_managament_2020")&&z("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Bo(e);const n=t.currentTree.version,o=mi();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Ei(q(t.graphsByVersion.get(n))))}}const xo=j.createContext({current:Oo}),Ut=()=>Po(xo),Fo=j.createContext(null);function Mi(){return Po(Fo)}function Sn(e,t,n){const o=yi(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[s,[l,u]]of a)u(n)}}function zo(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[s,l]of a)l(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!ko().early||t.suspendedComponentResolvers.size>0)&&(Sn(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Ii(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,zo(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):cn("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,z("recoil_memory_managament_2020")&&n==null&&Bo(e)}finally{t.commitDepth--}}function Ui({setNotifyBatcherOfChange:e}){const t=Ut(),[,n]=$i([]);return e(()=>n({})),nn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),nn(()=>{fa.enqueueExecution("Batcher",()=>{Ii(t.current)})}),null}function Di(e,t){const n=Uo();return t({set:(o,r)=>{const a=n.currentTree,s=bi(e,a,o.key,r),l=new Set(s.keys()),u=a.nonvalidatedAtoms.clone();for(const f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:pi(a.dirtyAtoms,l),atomValues:Ai(a.atomValues,s),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Ti(n.currentTree,a,r)})}}),n}function ki(e){const t=Ni(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let Bn=0;function Bi({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=C=>{const y=r.current.graphsByVersion;if(y.has(C))return q(y.get(C));const E=wi();return y.set(C,E),E},s=(C,y)=>{if(y==null){const{transactionSubscriptions:E}=_.current.getState(),Z=Bn++;return E.set(Z,C),{release:()=>{E.delete(Z)}}}else{const{nodeTransactionSubscriptions:E}=_.current.getState();E.has(y)||E.set(y,new Map);const Z=Bn++;return q(E.get(y)).set(Z,C),{release:()=>{const ne=E.get(y);ne&&(ne.delete(Z),ne.size===0&&E.delete(y))}}}},l=C=>{kn(_.current);for(const y of Object.keys(C))q(_.current.getState().nextTree).transactionMetadata[y]=C[y]},u=C=>{kn(_.current);const y=q(r.current.nextTree);let E;try{on=!0,E=C(y)}finally{on=!1}E!==y&&(r.current.nextTree=E,ko().early&&Sn(_.current,r.current,E),q(f.current)())},f=Vi(null),v=Li(C=>{f.current=C},[f]),_=Dn(()=>n??{storeID:Do(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:s,addTransactionMetadata:l});n!=null&&(_.current=n),r=Dn(()=>e!=null?Di(_.current,e):t!=null?ki(t):Uo());const V=Ci(()=>jt==null?void 0:jt(r,()=>r.current.currentTree.version),[r]);return nn(()=>{const C=_.current;for(const y of new Set(C.getState().knownAtoms))gi(C,y,"get");return()=>{for(const y of C.getState().knownAtoms)Ri(C,y)}},[_]),j.createElement(xo.Provider,{value:_},j.createElement(Fo.Provider,{value:V},j.createElement(Ui,{setNotifyBatcherOfChange:v}),o))}function Pi(e){const{override:t,...n}=e,o=Ut();return t===!1&&o.current!==Oo?e.children:j.createElement(Bi,n)}function Oi(){return Ut().current.storeID}var ge={RecoilRoot:Pi,useStoreRef:Ut,useRecoilMutableSource:Mi,useRecoilStoreID:Oi,notifyComponents_FOR_TESTING:Sn,sendEndOfBatchNotifications_FOR_TESTING:zo};function xi(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var Fi=xi;const{useEffect:zi,useRef:Wi}=j;function Gi(e){const t=Wi();return zi(()=>{t.current=e}),t.current}var Wo=Gi;const{useStoreRef:Ki}=ge,{SUSPENSE_TIMEOUT_MS:Hi}=$e,{updateRetainCount:Ze}=$e,{RetentionZone:qi}=Nt,{useEffect:ji,useRef:Zi}=j,{isSSR:Pn}=Vt;function Yi(e){if(z("recoil_memory_managament_2020"))return Xi(e)}function Xi(e){const n=(Array.isArray(e)?e:[e]).map(s=>s instanceof qi?s:s.key),o=Ki();ji(()=>{if(!z("recoil_memory_managament_2020"))return;const s=o.current;if(r.current&&!Pn)window.clearTimeout(r.current),r.current=null;else for(const l of n)Ze(s,l,1);return()=>{for(const l of n)Ze(s,l,-1)}},[o,...n]);const r=Zi(),a=Wo(n);if(!Pn&&(a===void 0||!Fi(a,n))){const s=o.current;for(const l of n)Ze(s,l,1);if(a)for(const l of a)Ze(s,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const l of n)Ze(s,l,-1)},Hi)}}var mn=Yi;function Ji(){return"<component name not available>"}var ct=Ji;const{batchUpdates:Qi}=Ct,{DEFAULT_VALUE:Go}=ie,{currentRendererSupportsUseSyncExternalStore:ec,reactMode:Ke,useMutableSource:tc,useSyncExternalStore:nc}=at,{useRecoilMutableSource:oc,useStoreRef:me}=ge,{AbstractRecoilValue:rn,getRecoilValueAsLoadable:lt,setRecoilValue:Rt,setUnvalidatedRecoilValue:rc,subscribeToRecoilValue:Fe}=Se,{useCallback:se,useEffect:ze,useMemo:Ko,useRef:nt,useState:Rn}=j,{setByAddingToSet:ac}=fo,{isSSR:sc}=Vt;function yn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),sc&&W(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:I(`Invalid value of loadable atom "${t.key}"`)}function ic(){const e=ct(),t=me(),[,n]=Rn([]),o=nt(new Set);o.current=new Set;const r=nt(new Set),a=nt(new Map),s=se(u=>{const f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=se((u,f)=>{a.current.has(f)&&n([])},[]);return ze(()=>{const u=t.current;et(o.current,r.current).forEach(f=>{if(a.current.has(f))return;const v=Fe(u,new rn(f),V=>l(V,f),e);a.current.set(f,v),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),et(r.current,o.current).forEach(f=>{s(f)}),r.current=o.current}),ze(()=>{const u=a.current;return et(o.current,new Set(u.keys())).forEach(f=>{const v=Fe(t.current,new rn(f),_=>l(_,f),e);u.set(f,v)}),()=>u.forEach((f,v)=>s(v))},[e,t,s,l]),Ko(()=>{function u(y){return E=>{Rt(t.current,y,E)}}function f(y){return()=>Rt(t.current,y,Go)}function v(y){var E;o.current.has(y.key)||(o.current=ac(o.current,y.key));const Z=t.current.getState();return lt(t.current,y,Ke().early&&(E=Z.nextTree)!==null&&E!==void 0?E:Z.currentTree)}function _(y){const E=v(y);return yn(E,y,t)}function V(y){return[_(y),u(y)]}function C(y){return[v(y),u(y)]}return{getRecoilValue:_,getRecoilValueLoadable:v,getRecoilState:V,getRecoilStateLoadable:C,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}const cc={current:0};function lc(e){const t=me(),n=ct(),o=se(()=>{var l;const u=t.current,f=u.getState(),v=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:lt(u,e,v),key:e.key}},[t,e]),r=se(l=>{let u;return()=>{var f,v;const _=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(_.loadable)&&((v=u)===null||v===void 0?void 0:v.key)===_.key?u:(u=_,_)}},[]),a=Ko(()=>r(o),[o,r]),s=se(l=>{const u=t.current;return Fe(u,e,l,n).release},[t,e,n]);return nc(s,a,a).loadable}function uc(e){const t=me(),n=se(()=>{var f;const v=t.current,_=v.getState(),V=Ke().early&&(f=_.nextTree)!==null&&f!==void 0?f:_.currentTree;return lt(v,e,V)},[t,e]),o=se(()=>n(),[n]),r=ct(),a=se((f,v)=>{const _=t.current;return Fe(_,e,()=>{if(!z("recoil_suppress_rerender_in_callback"))return v();const C=n();u.current.is(C)||v(),u.current=C},r).release},[t,e,r,n]),s=oc();if(s==null)throw I("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const l=tc(s,o,a),u=nt(l);return ze(()=>{u.current=l}),l}function an(e){const t=me(),n=ct(),o=se(()=>{var u;const f=t.current,v=f.getState(),_=Ke().early&&(u=v.nextTree)!==null&&u!==void 0?u:v.currentTree;return lt(f,e,_)},[t,e]),r=se(()=>({loadable:o(),key:e.key}),[o,e.key]),a=se(u=>{const f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);ze(()=>{const u=Fe(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);const[s,l]=Rn(r);return s.key!==e.key?r().loadable:s.loadable}function dc(e){const t=me(),[,n]=Rn([]),o=ct(),r=se(()=>{var l;const u=t.current,f=u.getState(),v=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return lt(u,e,v)},[t,e]),a=r(),s=nt(a);return ze(()=>{s.current=a}),ze(()=>{const l=t.current,u=l.getState(),f=Fe(l,e,_=>{var V;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const C=r();(V=s.current)!==null&&V!==void 0&&V.is(C)||n(C),s.current=C},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{s.current=null,n([])});else{var v;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const _=r();(v=s.current)!==null&&v!==void 0&&v.is(_)||n(_),s.current=_}return f.release},[o,r,e,t]),a}function gn(e){return z("recoil_memory_managament_2020")&&mn(e),{TRANSITION_SUPPORT:an,SYNC_EXTERNAL_STORE:ec()?lc:an,MUTABLE_SOURCE:uc,LEGACY:dc}[Ke().mode](e)}function Ho(e){const t=me(),n=gn(e);return yn(n,e,t)}function Dt(e){const t=me();return se(n=>{Rt(t.current,e,n)},[t,e])}function fc(e){const t=me();return se(()=>{Rt(t.current,e,Go)},[t,e])}function hc(e){return[Ho(e),Dt(e)]}function vc(e){return[gn(e),Dt(e)]}function pc(){const e=me();return(t,n={})=>{Qi(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>rc(e.current,new rn(r),o))})}}function qo(e){return z("recoil_memory_managament_2020")&&mn(e),an(e)}function jo(e){const t=me(),n=qo(e);return yn(n,e,t)}function _c(e){return[jo(e),Dt(e)]}var Sc={recoilComponentGetRecoilValueCount_FOR_TESTING:cc,useRecoilInterface:ic,useRecoilState:hc,useRecoilStateLoadable:vc,useRecoilValue:Ho,useRecoilValueLoadable:gn,useResetRecoilState:fc,useSetRecoilState:Dt,useSetUnvalidatedAtomValues:pc,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:qo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:jo,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:_c};function mc(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var Rc=mc;function yc(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var gc=yc;function bc(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Tc=bc;const{batchUpdates:wc}=Ct,{DEFAULT_VALUE:Ec,getNode:Zo,nodes:Ac}=ie,{useStoreRef:bn}=ge,{AbstractRecoilValue:Nc,setRecoilValueLoadable:Lc}=Se,{SUSPENSE_TIMEOUT_MS:Cc}=$e,{cloneSnapshot:yt}=It,{useCallback:kt,useEffect:Yo,useRef:On,useState:Vc}=j,{isSSR:xn}=Vt;function Bt(e){const t=bn();Yo(()=>t.current.subscribeToTransactions(e).release,[e,t])}function Fn(e){const t=e.atomValues.toMap(),n=mt(Rc(t,(o,r)=>{const s=Zo(r).persistence_UNSTABLE;return s!=null&&s.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Tc(e.nonvalidatedAtoms.toMap(),n)}function $c(e){Bt(kt(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=Fn(o),a=Fn(n),s=mt(Ac,u=>{var f,v,_,V;return{persistence_UNSTABLE:{type:(f=(v=u.persistence_UNSTABLE)===null||v===void 0?void 0:v.type)!==null&&f!==void 0?f:"none",backButton:(_=(V=u.persistence_UNSTABLE)===null||V===void 0?void 0:V.backButton)!==null&&_!==void 0?_:!1}}}),l=gc(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Mc(e){Bt(kt(t=>{const n=yt(t,"latest"),o=yt(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function Ic(){const e=bn(),[t,n]=Vc(()=>yt(e.current)),o=Wo(t),r=On(),a=On();if(Bt(kt(l=>n(yt(l)),[])),Yo(()=>{const l=t.retain();if(r.current&&!xn){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!xn){if(r.current){var s;window.clearTimeout(r.current),r.current=null,(s=a.current)===null||s===void 0||s.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},Cc)}return t}function Xo(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;wc(()=>{const s=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const v of f){var l,u;((l=r.atomValues.get(v))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(v))===null||u===void 0?void 0:u.contents)&&Zo(v).shouldRestoreFromSnapshots&&s.add(v)}s.forEach(f=>{Lc(e,new Nc(f),a.atomValues.has(f)?q(a.atomValues.get(f)):Ec)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function Uc(){const e=bn();return kt(t=>Xo(e.current,t),[e])}var Jo={useRecoilSnapshot:Ic,gotoSnapshot:Xo,useGotoRecoilSnapshot:Uc,useRecoilTransactionObserver:Mc,useTransactionObservation_DEPRECATED:$c,useTransactionSubscription_DEPRECATED:Bt};const{peekNodeInfo:Dc}=Te,{useStoreRef:kc}=ge;function Bc(){const e=kc();return({key:t})=>Dc(e.current,e.current.getState().currentTree,t)}var Pc=Bc;const{reactMode:Oc}=at,{RecoilRoot:xc,useStoreRef:Fc}=ge,{useMemo:zc}=j;function Wc(){Oc().mode==="MUTABLE_SOURCE"&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=Fc().current;return zc(()=>{function t({children:n}){return j.createElement(xc,{store_INTERNAL:e},n)}return t},[e])}var Gc=Wc;const{loadableWithValue:Kc}=rt,{initializeNode:Hc}=Te,{DEFAULT_VALUE:qc,getNode:jc}=ie,{copyTreeState:Zc,getRecoilValueAsLoadable:Yc,invalidateDownstreams:Xc,writeLoadableToTreeState:Jc}=Se;function zn(e){return jc(e.key).nodeType==="atom"}class Qc{constructor(t,n){M(this,"_store",void 0),M(this,"_treeState",void 0),M(this,"_changes",void 0),M(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!zn(o))throw I("Reading selectors within atomicUpdate is not supported");const r=Yc(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:I(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),M(this,"set",(o,r)=>{if(!zn(o))throw I("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else Hc(this._store,o.key,"set"),this._changes.set(o.key,r)}),M(this,"reset",o=>{this.set(o,qc)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=Zc(this._treeState);for(const[n,o]of this._changes)Jc(t,n,Kc(o));return Xc(this._store,t),t}}function el(e){return t=>{e.replaceState(n=>{const o=new Qc(e,n);return t(o),o.newTreeState_INTERNAL()})}}var tl={atomicUpdater:el},nl=tl.atomicUpdater,Qo=Object.freeze({__proto__:null,atomicUpdater:nl});function ol(e,t){if(!e)throw new Error(t)}var rl=ol,Qe=rl;const{atomicUpdater:al}=Qo,{batchUpdates:sl}=Ct,{DEFAULT_VALUE:il}=ie,{useStoreRef:cl}=ge,{refreshRecoilValue:ll,setRecoilValue:Wn}=Se,{cloneSnapshot:ul}=It,{gotoSnapshot:dl}=Jo,{useCallback:fl}=j;class er{}const hl=new er;function tr(e,t,n,o){let r=hl,a;if(sl(()=>{const l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw I(l);const u=ho({...o??{},set:(v,_)=>Wn(e,v,_),reset:v=>Wn(e,v,il),refresh:v=>ll(e,v),gotoSnapshot:v=>dl(e,v),transact_UNSTABLE:v=>al(e)(v)},{snapshot:()=>{const v=ul(e);return a=v.retain(),v}}),f=t(u);if(typeof f!="function")throw I(l);r=f(...n)}),r instanceof er&&Qe(!1),W(r))r=r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var s;(s=a)===null||s===void 0||s()}return r}function vl(e,t){const n=cl();return fl((...o)=>tr(n.current,e,o),t!=null?[...t,n]:void 0)}var nr={recoilCallback:tr,useRecoilCallback:vl};const{useStoreRef:pl}=ge,{refreshRecoilValue:_l}=Se,{useCallback:Sl}=j;function ml(e){const t=pl();return Sl(()=>{const n=t.current;_l(n,e)},[e,t])}var Rl=ml;const{atomicUpdater:yl}=Qo,{useStoreRef:gl}=ge,{useMemo:bl}=j;function Tl(e,t){const n=gl();return bl(()=>(...o)=>{yl(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var wl=Tl;class El{constructor(t){M(this,"value",void 0),this.value=t}}var Al={WrappedValue:El},Nl=Al.WrappedValue,or=Object.freeze({__proto__:null,WrappedValue:Nl});const{isFastRefreshEnabled:Ll}=at;class Gn extends Error{}class Cl{constructor(t){var n,o,r;M(this,"_name",void 0),M(this,"_numLeafs",void 0),M(this,"_root",void 0),M(this,"_onHit",void 0),M(this,"_onSet",void 0),M(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,s,l,u;let f,v;for(const[Z,ne]of t){var _,V,C;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const B=f;if(f=B?B.branches.get(v):w,f=(_=f)!==null&&_!==void 0?_:{type:"branch",nodeKey:Z,parent:B,branches:new Map,branchKey:v},f.type!=="branch"||f.nodeKey!==Z)throw this.invalidCacheError();B==null||B.branches.set(v,f),o==null||(V=o.onNodeVisit)===null||V===void 0||V.call(o,f),v=this._mapNodeValue(ne),this._root=(C=this._root)!==null&&C!==void 0?C:f}const y=f?(a=f)===null||a===void 0?void 0:a.branches.get(v):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==v))throw this.invalidCacheError();const E={type:"leaf",value:n,parent:f,branchKey:v};(s=f)===null||s===void 0||s.branches.set(v,E),this._root=(l=this._root)!==null&&l!==void 0?l:E,this._numLeafs++,this._onSet(E),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,E)};try{r()}catch(a){if(a instanceof Gn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const t=Ll()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw cn(t+(this._name!=null?` - ${this._name}`:"")),new Gn}}var Vl={TreeCache:Cl},$l=Vl.TreeCache,rr=Object.freeze({__proto__:null,TreeCache:$l});class Ml{constructor(t){var n;M(this,"_maxSize",void 0),M(this,"_size",void 0),M(this,"_head",void 0),M(this,"_tail",void 0),M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),s={key:t,right:a,left:null,value:n};a?a.left=s:this._tail=s,this._map.set(o,s),this._head=s,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=q(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var Il={LRUCache:Ml},Ul=Il.LRUCache,ar=Object.freeze({__proto__:null,LRUCache:Ul});const{LRUCache:Dl}=ar,{TreeCache:kl}=rr;function Bl({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new Dl({maxSize:t}),r=new kl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const s=o.tail();o.set(a,!0),s&&r.size()>t&&r.delete(s.key)}});return r}var Kn=Bl;function _e(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw I("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(W(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>_e(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return _e(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:_e(a,t)]=s;return _e(r,t,n)}return e instanceof Set?_e(Array.from(e).sort((r,a)=>_e(r,t).localeCompare(_e(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?_e(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${_e(r,t)}:${_e(e[r],t,r)}`).join(",")}}`}function Pl(e,t={allowFunctions:!1}){return _e(e,t)}var Pt=Pl;const{TreeCache:Ol}=rr,dt={equality:"reference",eviction:"keep-all",maxSize:1/0};function xl({equality:e=dt.equality,eviction:t=dt.eviction,maxSize:n=dt.maxSize}=dt,o){const r=Fl(e);return zl(t,n,r,o)}function Fl(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw I(`Unrecognized equality policy ${e}`)}function zl(e,t,n,o){switch(e){case"keep-all":return new Ol({name:o,mapNodeValue:n});case"lru":return Kn({name:o,maxSize:q(t),mapNodeValue:n});case"most-recent":return Kn({name:o,maxSize:1,mapNodeValue:n})}throw I(`Unrecognized eviction policy ${e}`)}var Wl=xl;function Gl(e){return()=>null}var Kl={startPerfBlock:Gl};const{isLoadable:Hl,loadableWithError:ft,loadableWithPromise:ql,loadableWithValue:Zt}=rt,{WrappedValue:sr}=or,{getNodeLoadable:ht,peekNodeLoadable:jl,setNodeValue:Zl}=Te,{saveDepsToStore:Yl}=st,{DEFAULT_VALUE:Xl,getConfigDeletionHandler:Jl,getNode:Ql,registerNode:Hn}=ie,{isRecoilValue:eu}=xe,{markRecoilValueModified:qn}=Se,{retainedByOptionWithDefault:tu}=$e,{recoilCallback:nu}=nr,{startPerfBlock:ou}=Kl;class ir{}const Ye=new ir,Xe=[],vt=new Map,ru=(()=>{let e=0;return()=>e++})();function cr(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,s=new Set,l=Wl(r??{equality:"reference",eviction:"keep-all"},n),u=tu(e.retainedBy_UNSTABLE),f=new Map;let v=0;function _(){return!z("recoil_memory_managament_2020")||v>0}function V(d){return d.getState().knownSelectors.add(n),v++,()=>{v--}}function C(){return Jl(n)!==void 0&&!_()}function y(d,p,S,$,b){de(p,$,b),E(d,S)}function E(d,p){ce(d,p)&&Q(d),ne(p,!0)}function Z(d,p){ce(d,p)&&(q(ee(d)).stateVersions.clear(),ne(p,!1))}function ne(d,p){const S=vt.get(d);if(S!=null){for(const $ of S)qn($,q(t));p&&vt.delete(d)}}function w(d,p){let S=vt.get(p);S==null&&vt.set(p,S=new Set),S.add(d)}function B(d,p,S,$,b,k){return p.then(D=>{if(!_())throw Q(d),Ye;const T=Zt(D);return y(d,S,b,T,$),D}).catch(D=>{if(!_())throw Q(d),Ye;if(W(D))return J(d,D,S,$,b,k);const T=ft(D);throw y(d,S,b,T,$),D})}function J(d,p,S,$,b,k){return p.then(D=>{if(!_())throw Q(d),Ye;k.loadingDepKey!=null&&k.loadingDepPromise===p?S.atomValues.set(k.loadingDepKey,Zt(D)):d.getState().knownSelectors.forEach(x=>{S.atomValues.delete(x)});const T=Y(d,S);if(T&&T.state!=="loading"){if((ce(d,b)||ee(d)==null)&&E(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!ce(d,b)){const x=Re(d,S);if(x!=null)return x.loadingLoadable.contents}const[K,te]=G(d,S,b);if(K.state!=="loading"&&y(d,S,b,K,te),K.state==="hasError")throw K.contents;return K.contents}).catch(D=>{if(D instanceof ir)throw Ye;if(!_())throw Q(d),Ye;const T=ft(D);throw y(d,S,b,T,$),D})}function F(d,p,S,$){var b,k,D,T;if(ce(d,$)||p.version===((b=d.getState())===null||b===void 0||(k=b.currentTree)===null||k===void 0?void 0:k.version)||p.version===((D=d.getState())===null||D===void 0||(T=D.nextTree)===null||T===void 0?void 0:T.version)){var K,te,x;Yl(n,S,d,(K=(te=d.getState())===null||te===void 0||(x=te.nextTree)===null||x===void 0?void 0:x.version)!==null&&K!==void 0?K:d.getState().currentTree.version)}for(const X of S)s.add(X)}function G(d,p,S){const $=ou(n);let b=!0,k=!0;const D=()=>{$(),k=!1};let T,K=!1,te;const x={loadingDepKey:null,loadingDepPromise:null},X=new Map;function ve({key:fe}){const le=ht(d,p,fe);switch(X.set(fe,le),b||(F(d,p,new Set(X.keys()),S),Z(d,S)),le.state){case"hasValue":return le.contents;case"hasError":throw le.contents;case"loading":throw x.loadingDepKey=fe,x.loadingDepPromise=le.contents,le.contents}throw I("Invalid Loadable state")}const Ae=fe=>(...le)=>{if(k)throw I("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&Qe(!1),nu(d,fe,le,{node:t})};try{T=o({get:ve,getCallback:Ae}),T=eu(T)?ve(T):T,Hl(T)&&(T.state==="hasError"&&(K=!0),T=T.contents),W(T)?T=B(d,T,p,X,S,x).finally(D):D(),T=T instanceof sr?T.value:T}catch(fe){T=fe,W(T)?T=J(d,T,p,X,S,x).finally(D):(K=!0,D())}return K?te=ft(T):W(T)?te=ql(T):te=Zt(T),b=!1,Ie(d,S,X),F(d,p,new Set(X.keys()),S),[te,X]}function Y(d,p){let S=p.atomValues.get(n);if(S!=null)return S;const $=new Set;try{S=l.get(k=>(typeof k!="string"&&Qe(!1),ht(d,p,k).contents),{onNodeVisit:k=>{k.type==="branch"&&k.nodeKey!==n&&$.add(k.nodeKey)}})}catch(k){throw I(`Problem with cache lookup for selector "${n}": ${k.message}`)}if(S){var b;p.atomValues.set(n,S),F(d,p,$,(b=ee(d))===null||b===void 0?void 0:b.executionID)}return S}function re(d,p){const S=Y(d,p);if(S!=null)return Q(d),S;const $=Re(d,p);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&w(d,$.executionID),$.loadingLoadable}const k=ru(),[D,T]=G(d,p,k);return D.state==="loading"?(ue(d,k,D,T,p),w(d,k)):(Q(d),de(p,D,T)),D}function Re(d,p){const S=Vo([f.has(d)?[q(f.get(d))]:[],Et(hn(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(const[k,D]of b)if(!ht(d,p,k).is(D))return!0;return!1}for(const b of S){if(b.stateVersions.get(p.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(p.version,!0),b;b.stateVersions.set(p.version,!1)}}function ee(d){return f.get(d)}function ue(d,p,S,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:p,loadingLoadable:S,stateVersions:new Map([[b.version,!0]])})}function Ie(d,p,S){if(ce(d,p)){const $=ee(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=S)}}function Q(d){f.delete(d)}function ce(d,p){var S;return p===((S=ee(d))===null||S===void 0?void 0:S.executionID)}function Ee(d){return Array.from(d.entries()).map(([p,S])=>[p,S.contents])}function de(d,p,S){d.atomValues.set(n,p);try{l.set(Ee(S),p)}catch($){throw I(`Problem with setting cache for selector "${n}": ${$.message}`)}}function ye(d){if(Xe.includes(n)){const p=`Recoil selector has circular dependencies: ${Xe.slice(Xe.indexOf(n)).join(" → ")}`;return ft(I(p))}Xe.push(n);try{return d()}finally{Xe.pop()}}function Ue(d,p){const S=p.atomValues.get(n);return S??l.get($=>{var b;return typeof $!="string"&&Qe(!1),(b=jl(d,p,$))===null||b===void 0?void 0:b.contents})}function De(d,p){return ye(()=>re(d,p))}function P(d){d.atomValues.delete(n)}function O(d,p){t==null&&Qe(!1);for(const $ of s){var S;const b=Ql($);(S=b.clearCache)===null||S===void 0||S.call(b,d,p)}s.clear(),P(p),l.clear(),qn(d,t)}return a!=null?t=Hn({key:n,nodeType:"selector",peek:Ue,get:De,set:(p,S,$)=>{let b=!1;const k=new Map;function D({key:x}){if(b)throw I("Recoil: Async selector sets are not currently supported.");const X=ht(p,S,x);if(X.state==="hasValue")return X.contents;if(X.state==="loading"){const ve=`Getting value of asynchronous atom or selector "${x}" in a pending state while setting selector "${n}" is not yet supported.`;throw I(ve)}else throw X.contents}function T(x,X){if(b)throw I("Recoil: Async selector sets are not currently supported.");const ve=typeof X=="function"?X(D(x)):X;Zl(p,S,x.key,ve).forEach((fe,le)=>k.set(le,fe))}function K(x){T(x,Xl)}const te=a({set:T,get:D,reset:K},$);if(te!==void 0)throw W(te)?I("Recoil: Async selector sets are not currently supported."):I("Recoil: selector set should be a void function.");return b=!0,k},init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=Hn({key:n,nodeType:"selector",peek:Ue,get:De,init:V,invalidate:P,clearCache:O,shouldDeleteConfigOnRelease:C,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}cr.value=e=>new sr(e);var We=cr;const{isLoadable:au,loadableWithError:Yt,loadableWithPromise:Xt,loadableWithValue:Be}=rt,{WrappedValue:lr}=or,{peekNodeInfo:su}=Te,{DEFAULT_VALUE:Ne,DefaultValue:be,getConfigDeletionHandler:ur,registerNode:iu,setConfigDeletionHandler:cu}=ie,{isRecoilValue:lu}=xe,{getRecoilValueAsLoadable:uu,markRecoilValueModified:du,setRecoilValue:jn,setRecoilValueLoadable:fu}=Se,{retainedByOptionWithDefault:hu}=$e,Je=e=>e instanceof lr?e.value:e;function vu(e){const{key:t,persistence_UNSTABLE:n}=e,o=hu(e.retainedBy_UNSTABLE);let r=0;function a(w){return Xt(w.then(B=>(s=Be(B),B)).catch(B=>{throw s=Yt(B),B}))}let s=W(e.default)?a(e.default):au(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:Be(Je(e.default));s.contents;let l;const u=new Map;function f(w){return w}function v(w,B){const J=B.then(F=>{var G,Y;return((Y=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||Y===void 0?void 0:Y.contents)===J&&jn(w,ne,F),F}).catch(F=>{var G,Y;throw((Y=((G=w.getState().nextTree)!==null&&G!==void 0?G:w.getState().currentTree).atomValues.get(t))===null||Y===void 0?void 0:Y.contents)===J&&fu(w,ne,Yt(F)),F});return J}function _(w,B,J){var F;r++;const G=()=>{var ee;r--,(ee=u.get(w))===null||ee===void 0||ee.forEach(ue=>ue()),u.delete(w)};if(w.getState().knownAtoms.add(t),s.state==="loading"){const ee=()=>{var ue;((ue=w.getState().nextTree)!==null&&ue!==void 0?ue:w.getState().currentTree).atomValues.has(t)||du(w,ne)};s.contents.finally(ee)}const Y=(F=e.effects)!==null&&F!==void 0?F:e.effects_UNSTABLE;if(Y!=null){let ee=function(P){if(ce&&P.key===t){const O=Q;return O instanceof be?V(w,B):W(O)?Xt(O.then(d=>d instanceof be?s.toPromise():d)):Be(O)}return uu(w,P)},ue=function(P){return ee(P).toPromise()},Ie=function(P){var O;const d=su(w,(O=w.getState().nextTree)!==null&&O!==void 0?O:w.getState().currentTree,P.key);return ce&&P.key===t&&!(Q instanceof be)?{...d,isSet:!0,loadable:ee(P)}:d},Q=Ne,ce=!0,Ee=!1,de=null;const ye=P=>O=>{if(ce){const d=ee(ne),p=d.state==="hasValue"?d.contents:Ne;Q=typeof O=="function"?O(p):O,W(Q)&&(Q=Q.then(S=>(de={effect:P,value:S},S)))}else{if(W(O))throw I("Setting atoms to async values is not implemented.");typeof O!="function"&&(de={effect:P,value:Je(O)}),jn(w,ne,typeof O=="function"?d=>{const p=Je(O(d));return de={effect:P,value:p},p}:Je(O))}},Ue=P=>()=>ye(P)(Ne),De=P=>O=>{var d;const{release:p}=w.subscribeToTransactions(S=>{var $;let{currentTree:b,previousTree:k}=S.getState();k||(k=b);const D=($=b.atomValues.get(t))!==null&&$!==void 0?$:s;if(D.state==="hasValue"){var T,K,te,x;const X=D.contents,ve=(T=k.atomValues.get(t))!==null&&T!==void 0?T:s,Ae=ve.state==="hasValue"?ve.contents:Ne;((K=de)===null||K===void 0?void 0:K.effect)!==P||((te=de)===null||te===void 0?void 0:te.value)!==X?O(X,Ae,!b.atomValues.has(t)):((x=de)===null||x===void 0?void 0:x.effect)===P&&(de=null)}},t);u.set(w,[...(d=u.get(w))!==null&&d!==void 0?d:[],p])};for(const P of Y)try{const O=P({node:ne,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:J,setSelf:ye(P),resetSelf:Ue(P),onSet:De(P),getPromise:ue,getLoadable:ee,getInfo_UNSTABLE:Ie});if(O!=null){var re;u.set(w,[...(re=u.get(w))!==null&&re!==void 0?re:[],O])}}catch(O){Q=O,Ee=!0}if(ce=!1,!(Q instanceof be)){var Re;const P=Ee?Yt(Q):W(Q)?Xt(v(w,Q)):Be(Je(Q));P.contents,B.atomValues.set(t,P),(Re=w.getState().nextTree)===null||Re===void 0||Re.atomValues.set(t,P)}}return G}function V(w,B){var J,F;return(J=(F=B.atomValues.get(t))!==null&&F!==void 0?F:l)!==null&&J!==void 0?J:s}function C(w,B){if(B.atomValues.has(t))return q(B.atomValues.get(t));if(B.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return s;const J=B.nonvalidatedAtoms.get(t),F=n.validator(J,Ne);return l=F instanceof be?s:Be(F),l}else return s}function y(){l=void 0}function E(w,B,J){if(B.atomValues.has(t)){const F=q(B.atomValues.get(t));if(F.state==="hasValue"&&J===F.contents)return new Map}else if(!B.nonvalidatedAtoms.has(t)&&J instanceof be)return new Map;return l=void 0,new Map().set(t,Be(J))}function Z(){return ur(t)!==void 0&&r<=0}const ne=iu({key:t,nodeType:"atom",peek:V,get:C,set:E,init:_,invalidate:y,shouldDeleteConfigOnRelease:Z,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return ne}function Tn(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return lu(n)?pu({...t,default:n}):vu({...t,default:n})}function pu(e){const t=Tn({...e,default:Ne,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof be?o:q(e.persistence_UNSTABLE).validator(o,Ne)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=We({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof be?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return cu(n.key,ur(e.key)),n}Tn.value=e=>new lr(e);var dr=Tn;class _u{constructor(t){var n;M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Su={MapCache:_u},mu=Su.MapCache,Ru=Object.freeze({__proto__:null,MapCache:mu});const{LRUCache:Zn}=ar,{MapCache:yu}=Ru,pt={equality:"reference",eviction:"none",maxSize:1/0};function gu({equality:e=pt.equality,eviction:t=pt.eviction,maxSize:n=pt.maxSize}=pt){const o=bu(e);return Tu(t,n,o)}function bu(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw I(`Unrecognized equality policy ${e}`)}function Tu(e,t,n){switch(e){case"keep-all":return new yu({mapKey:n});case"lru":return new Zn({mapKey:n,maxSize:q(t)});case"most-recent":return new Zn({mapKey:n,maxSize:1})}throw I(`Unrecognized eviction policy ${e}`)}var fr=gu;const{setConfigDeletionHandler:wu}=ie;function Eu(e){var t,n;const o=fr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,s;const l=o.get(r);if(l!=null)return l;const{cachePolicyForParams_UNSTABLE:u,...f}=e,v="default"in e?e.default:new Promise(()=>{}),_=dr({...f,key:`${e.key}__${(a=Pt(r))!==null&&a!==void 0?a:"void"}`,default:typeof v=="function"?v(r):v,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(s=e.effects)!==null&&s!==void 0?s:e.effects_UNSTABLE});return o.set(r,_),wu(_.key,()=>{o.delete(r)}),_}}var Au=Eu;const{setConfigDeletionHandler:Nu}=ie;let Lu=0;function Cu(e){var t,n;const o=fr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let s;try{s=o.get(r)}catch(V){throw I(`Problem with cache lookup for selector ${e.key}: ${V.message}`)}if(s!=null)return s;const l=`${e.key}__selectorFamily/${(a=Pt(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${Lu++}`,u=V=>e.get(r)(V),f=e.cachePolicy_UNSTABLE,v=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let _;if(e.set!=null){const V=e.set;_=We({key:l,get:u,set:(y,E)=>V(r)(y,E),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v})}else _=We({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v});return o.set(r,_),Nu(_.key,()=>{o.delete(r)}),_}}var we=Cu;const Vu=we({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function $u(e){return Vu(e)}var Mu=$u;const Iu=we({key:"__error",get:e=>()=>{throw I(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Uu(e){return Iu(e)}var Du=Uu;function ku(e){return e}var Bu=ku;const{loadableWithError:hr,loadableWithPromise:vr,loadableWithValue:pr}=rt;function Ot(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function Pu(e){return e!=null&&!W(e)}function xt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function sn(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Pe(e,t,n){const o=n.map((r,a)=>r==null?pr(t[a]):W(r)?vr(r):hr(r));return sn(e,o)}function Ou(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const xu=we({key:"__waitForNone",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return Pe(e,o,r)},dangerouslyAllowMutability:!0}),Fu=we({key:"__waitForAny",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return r.some(a=>!W(a))?Pe(e,o,r):new Promise(a=>{for(const[s,l]of r.entries())W(l)&&l.then(u=>{o[s]=u,r[s]=void 0,a(Pe(e,o,r))}).catch(u=>{r[s]=u,a(Pe(e,o,r))})})},dangerouslyAllowMutability:!0}),zu=we({key:"__waitForAll",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);if(r.every(s=>s==null))return sn(e,o);const a=r.find(Pu);if(a!=null)throw a;return Promise.all(r).then(s=>sn(e,Ou(o,s)))},dangerouslyAllowMutability:!0}),Wu=we({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return r.every(a=>!W(a))?Pe(e,o,r):Promise.all(r.map((a,s)=>W(a)?a.then(l=>{o[s]=l,r[s]=void 0}).catch(l=>{o[s]=void 0,r[s]=l}):null)).then(()=>Pe(e,o,r))},dangerouslyAllowMutability:!0}),Gu=we({key:"__noWait",get:e=>({get:t})=>{try{return We.value(pr(t(e)))}catch(n){return We.value(W(n)?vr(n):hr(n))}},dangerouslyAllowMutability:!0});var Ku={waitForNone:xu,waitForAny:Fu,waitForAll:zu,waitForAllSettled:Wu,noWait:Gu};const{RecoilLoadable:Hu}=rt,{DefaultValue:qu}=ie,{RecoilRoot:ju,useRecoilStoreID:Zu}=ge,{isRecoilValue:Yu}=xe,{retentionZone:Xu}=Nt,{freshSnapshot:Ju}=It,{useRecoilState:Qu,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ed,useRecoilStateLoadable:td,useRecoilValue:nd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:od,useRecoilValueLoadable:rd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ad,useResetRecoilState:sd,useSetRecoilState:id}=Sc,{useGotoRecoilSnapshot:cd,useRecoilSnapshot:ld,useRecoilTransactionObserver:ud}=Jo,{useRecoilCallback:dd}=nr,{noWait:fd,waitForAll:hd,waitForAllSettled:vd,waitForAny:pd,waitForNone:_d}=Ku;var Me={DefaultValue:qu,isRecoilValue:Yu,RecoilLoadable:Hu,RecoilEnv:Ge,RecoilRoot:ju,useRecoilStoreID:Zu,useRecoilBridgeAcrossReactRoots_UNSTABLE:Gc,atom:dr,selector:We,atomFamily:Au,selectorFamily:we,constSelector:Mu,errorSelector:Du,readOnlySelector:Bu,noWait:fd,waitForNone:_d,waitForAny:pd,waitForAll:hd,waitForAllSettled:vd,useRecoilValue:nd,useRecoilValueLoadable:rd,useRecoilState:Qu,useRecoilStateLoadable:td,useSetRecoilState:id,useResetRecoilState:sd,useGetRecoilValueInfo_UNSTABLE:Pc,useRecoilRefresher_UNSTABLE:Rl,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ad,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:od,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ed,useRecoilCallback:dd,useRecoilTransaction_UNSTABLE:wl,useGotoRecoilSnapshot:cd,useRecoilSnapshot:ld,useRecoilTransactionObserver_UNSTABLE:ud,snapshot_UNSTABLE:Ju,useRetain:mn,retentionZone:Xu},Rd=Me.RecoilRoot,yd=Me.atom,gd=Me.atomFamily,bd=Me.selectorFamily,Td=Me.useRecoilValue,wd=Me.useRecoilState,Ed=Me.useSetRecoilState;export{yd as R,Td as a,wd as b,gd as c,bd as d,Ed as e,Rd as f};
